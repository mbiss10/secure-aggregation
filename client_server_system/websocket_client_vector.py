import asyncio
import sys
import websockets
import argparse
import random
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
import pickle


class SecureAggClient:
    """ Class representing a client in the secure aggregation protocol.
    Initialized with:
        - a set of private values that will be aggregated (element-wise) with other clients
        - a websocket connection to the server
        - a boolean indicating whether or not to generate a new RSA keypair """

    def __init__(self, values, connection, generate_keys=False):
        # Base is received from the server
        self.base = None

        # Generate RSA keys if necessary
        if generate_keys:
            self.rsa_keys = RSA.generate(2048)
            self.priv_key = self.rsa_keys.export_key()
            self.pub_key = self.rsa_keys.publickey().export_key()
        else:
            self.init_keys_from_file(
                "./keys/public.pem", "./keys/private.pem")

        # Store the perturbations received from other clients
        self.peer_perturbations = {}
        # Store the perturbations that this client will send to other clients
        self.perturbation_messages = {}
        # The websocket connection to the server
        self.connection = connection
        # The client's ID, which is the IP address and port of the connection
        self.id = f"{connection.local_address[0]}:{connection.local_address[1]}"
        # The client's private values
        self.values = values
        # The number of values this client has
        self.num_values = len(values)

    def set_base(self, base: int):
        self.base = base

    def init_keys_from_file(self, pubkey_filepath, privkey_filepath):
        with open(pubkey_filepath, "rb") as f:
            self.pub_key = f.read()
        with open(privkey_filepath, "rb") as f:
            self.priv_key = f.read()

    def create_perturbation_messages(self, public_key_dict):
        """
        Create perturbation vectors to send to each of the other clients.
        Each message is encrypted with the public key of the recipient.
        """

        assert self.base is not None, "Base must be set before creating perturbations."

        for peer, peer_pub_key_str in public_key_dict.items():
            if peer == self.id:
                continue

            # Generate random values for this peer and prep for encryption
            peer_perturb_vals = [random.randint(
                0, self.base-1) for _ in range(self.num_values)]
            data = ",".join([str(val)
                            for val in peer_perturb_vals]).encode("utf-8")

            # Store the unencrypted perturbation value for this client to use when computing
            # the value to send to the server
            self.peer_perturbations[peer] = peer_perturb_vals

            # Use an AES session key so that we can encrypt arbitrarily large data.
            # If we only used RSA, we'd be limited to the size of the key.
            session_key = get_random_bytes(16)

            # Encrypt the session key with the peer's public RSA key.
            # Note that we're sending public keys as strings generated by the export_key
            # method, so we need to convert them back to RSA objects.
            peer_pub_key = RSA.import_key(peer_pub_key_str)
            cipher_rsa = PKCS1_OAEP.new(peer_pub_key)
            enc_session_key = cipher_rsa.encrypt(session_key)

            # Encrypt the data with the AES session key
            cipher_aes = AES.new(session_key, AES.MODE_EAX)
            ciphertext, tag = cipher_aes.encrypt_and_digest(data)

            # Store the message that will be sent to the peer
            self.perturbation_messages[peer] = (
                enc_session_key, cipher_aes.nonce, tag, ciphertext)

    async def send_perturbations(self):
        await self.connection.send(pickle.dumps({"type": "perturbations", "perturbations": self.perturbation_messages}))

    def compute_values(self, received_peer_perturbations):
        """
        Compute the vector of masked values to send to the server.
        """
        to_send = [0] * self.num_values

        for peer, peer_perturb_message in received_peer_perturbations.items():
            if peer == self.id:
                continue
            else:
                # Decrypt the peer's message
                enc_session_key, nonce, tag, ciphertext = peer_perturb_message
                # First, decrypt the session key with the private RSA key
                cipher_rsa = PKCS1_OAEP.new(RSA.import_key((self.priv_key)))
                session_key = cipher_rsa.decrypt(enc_session_key)
                # Then, decrypt the data with the AES session key
                cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)
                raw_data = cipher_aes.decrypt_and_verify(ciphertext, tag)
                try:
                    received_perturb_val_str = raw_data.decode("utf-8")
                    received_perturb_vals = [
                        int(val) for val in received_perturb_val_str.split(",")]
                except ValueError:
                    print(
                        "Unable to decode recieved message. It may not be a valid list of ints.")

                # Compute the value to send to the server
                for (idx, val) in enumerate(received_perturb_vals):
                    s_uv = self.peer_perturbations[peer][idx]
                    s_vu = val
                    p_uv = (s_uv - s_vu) % self.base
                    to_send[idx] += p_uv

        return [(x + self.values[idx]) % self.base for (idx, x) in enumerate(to_send)]

    async def send_val(self, to_send):
        message = pickle.dumps(
            {"type": "value", "value": to_send})
        await self.connection.send(message)


async def main(values, host, port):

    async with websockets.connect(f"ws://{host}:{port}", ping_timeout=None, close_timeout=None) as websocket:
        client = SecureAggClient(values, websocket)
        print(f"I am Client [{client.id}]. Successfully connected to server.")

        await websocket.send(pickle.dumps({"type": "public_key", "public_key": client.pub_key}))

        # Response to all messages received over the websocket from the server using the appropriate handler
        async for m_raw in websocket:
            try:
                # Parse the message by unpickling
                m = pickle.loads(m_raw)
                print(f"Received message of type: {m['type']}")
                message_type = m["type"]
            except (TypeError, ValueError, KeyError) as e:
                print(f"Error: {e}")
                continue

            if message_type == 'public_key_broadcast':
                # create perturbations and send to all peers
                client.create_perturbation_messages(m['public_keys'])
                await client.send_perturbations()

            elif message_type == 'init_base_param':
                print(f"Received base parameter from server: {m['base']}")
                client.set_base(m['base'])

            elif message_type == 'perturbations':
                to_send = client.compute_values(m["perturbations"])
                await client.send_val(to_send)

            elif message_type == 'aggregation_result':
                print(f"Final aggregation result ðŸ˜Ž: {m['aggregation_result']}")
                return m['aggregation_result']

            elif message_type == 'message':
                print(f"Received message: {m['message']}")

            else:
                print(f"Received unknown message type: {message_type}")

        print("Connection closed.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("-v", "--values",
                        help="This client's values as a comma separated string (no spaces) e.g. '1,2,3'", type=str)
    parser.add_argument("-h", "--host",
                        help="Hostname", type=int)
    parser.add_argument("-p", "--port",
                        help="Port", type=int)
    args = parser.parse_args()

    if len(sys.argv) < 2:
        print(
            f"Usage: python3 websocket_client.py -v <client_value")
        exit(1)

    if not args.host:
        args.host = "localhost"
    if not args.port:
        args.port = 8001

    try:
        values = [int(v) for v in args.values.split(",")]
    except:
        print("Error: values must be a comma separated string of ints")
        exit(1)

    asyncio.run(main(values, args.host, args.port))
